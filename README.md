# PE_Injection

### 1. 목적
개발한 DLL을 특정 인증된 Application에서만 실행가능하도록 한다. 
- DLL을 아무나 사용하지 못하도록 해야할 경우
- DLL 사용자를 관리하고자 하는 경우(외부 개발자가 최종 릴리즈 요청하면 인증키를 EXE에 삽입해준다)
      
### 2. 구조
DLL에서 자신을 호출한 EXE의 정보를 분석한다. EXE의 해더(PE)에서 인증 정보가 있으면 DLL 내의 메시지 함수를 제거한다.
메시지 함수는 디버깅을 어렵게 하기위해서 Assembly 형태의 배열로 만들어 사용한다.
![](http://postfiles7.naver.net/20110901_230/adsloader_1314864120480cdBBz_PNG/1.PNG?type=w2)

### 3. VC++에서 어셈블리 보기
디버깅을 하는 중에 ALT+8을 입력하여 어셈블리 모드로 진입가능하다.

![](http://postfiles11.naver.net/20110901_154/adsloader_1314843877413nLAWJ_PNG/1.PNG?type=w2)

함수의 시작점과 끝점의 주소를 본 후, ALT + 6을 누르면 브레이크포인트가 있는 시점의 메모리가 덤프된다.

![](http://postfiles7.naver.net/20110901_86/adsloader_1314864747899IXM24_PNG/2.PNG?type=w2)

위와 같이 하여 원하는 함수를 OPCode 형태의 배열로 만들어서 캐스팅하여 사용하면 해킹을 하고자 하는 사람들에게 짜증을
늘려줄 수 있다.

보통 OllyDBG나 기타 디버거로 Trace하는 경우, API를 기준으로 브레이크 포인트를 걸게되는 데, 이 방법을 사용하게 되면
브레이크포인트가 걸리지 않는다.(그렇다고 해킹이 불가능 해 지는 것도 아니지만 짜증은 확실히 생긴다).

~~~C++
ex)

// 함수를 OPCODE 배열로 저장했다.
BYTE DISPLAY_MESSAGE[] =
{
    0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x58, 0x53, 0x56, 0x57, 0x8D, 0x7D, 0xA8, 0xB9, 0x16, 0x00,
    0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xF3, 0xAB, 0xC6, 0x45, 0xF4, 0x41, 0xC6, 0x45,
    0xF5, 0x50, 0xC6, 0x45, 0xF6, 0x49, 0xC6, 0x45, 0xF7, 0x20, 0xC6, 0x45, 0xF8, 0x54, 0xC6,
    0x45, 0xF9, 0x45, 0xC6, 0x45, 0xFA, 0x53, 0xC6, 0x45, 0xFB, 0x54, 0xC6, 0x45, 0xFC, 0x00,
    0xC6, 0x45, 0xEC, 0x43, 0xC6, 0x45, 0xED, 0x41, 0xC6, 0x45, 0xEE, 0x50, 0xC6, 0x45, 0xEF,
    0x54, 0xC6, 0x45, 0xF0, 0x49, 0xC6, 0x45, 0xF1, 0x4F, 0xC6, 0x45, 0xF2, 0x4E, 0xC6, 0x45,
    0xF3, 0x00, 0x8B, 0x45, 0x08, 0x89, 0x45, 0xE8, 0x8B, 0xF4, 0x6A, 0x00, 0x8D, 0x4D, 0xEC,
    0x51, 0x8D, 0x55, 0xF4, 0x52, 0x6A, 0x00, 0xFF, 0x55, 0xE8, 0x3B, 0xF4, 
    0x90, 0x5F, 0x5E, 0x5B, 0x83, 0xC4, 0x58, 0x3B, 0xEC, 
    0x8B, 0xE5, 0x5D, 0xC3
};
...

// 배열을 원래 함수형으로 캐스팅하여 실행한다.
void (*fnNoty)(DWORD);
fnNoty = ( void (__cdecl*)(DWORD) )&ENCODING_DISPLAY_MESSAGE;
~~~
